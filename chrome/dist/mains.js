!function(e){var t={};function r(o){if(t[o])return t[o].exports;var s=t[o]={i:o,l:!1,exports:{}};return e[o].call(s.exports,s,s.exports,r),s.l=!0,s.exports}r.m=e,r.c=t,r.d=function(e,t,o){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:o})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(r.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)r.d(o,s,function(t){return e[t]}.bind(null,s));return o},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=6)}([function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.UdpResponse=t.UdpResponseData=t.DataFlowStub=void 0,t.DataFlowStub={UdpRequestData:class{constructor(){this.protocol=smarthome.Constants.Protocol.UDP,this.requestId="",this.deviceId="",this.data="",this.port=0}}};t.UdpResponseData=class{constructor(e,t,r){this.protocol=smarthome.Constants.Protocol.UDP,this.requestId=e,this.deviceId=t,this.udpResponse=r}};t.UdpResponse=class{constructor(e){this.responsePackets=e}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractStubs=t.smarthomeStub=void 0;const o=r(2),s=r(5),n=r(0);t.smarthomeStub={App:o.AppStub,Execute:s.ExecuteStub,Intents:{EXECUTE:"action.devices.EXECUTE",IDENTIFY:"action.devices.IDENTIFY",REACHABLE_DEVICES:"action.devices.REACHABLE_DEVICES"},IntentFlow:{HandlerError:class extends Error{constructor(e,t,r){super(t),this.requestId=e,this.errorCode=t||"",this.debugString=r}}},DataFlow:n.DataFlowStub,Constants:{Protocol:{BLE:"BLE",HTTP:"HTTP",TCP:"TCP",UDP:"UDP",BLE_MESH:"BLE_MESH"}}},t.extractStubs=function(e){if(e instanceof o.AppStub)return{mockLocalHomePlatform:e.getLocalHomePlatform(),deviceManagerStub:e.getLocalHomePlatform().getDeviceManager()};throw new Error("Couldn't downcast App to AppStub")}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.AppStub=t.ERROR_HANDLERS_NOT_SET=t.ERROR_LISTEN_WITHOUT_EXECUTE_HANDLER=t.ERROR_LISTEN_WITHOUT_IDENTIFY_HANDLER=void 0;const o=r(3);t.ERROR_LISTEN_WITHOUT_IDENTIFY_HANDLER="Identify handler must be set before listen() can be called",t.ERROR_LISTEN_WITHOUT_EXECUTE_HANDLER="Execute handler must be set before listen() can be called",t.ERROR_HANDLERS_NOT_SET="All handlers must be set and listen() must be called before accessing the Platform";t.AppStub=class{constructor(e){this.allHandlersSet=!1,this.version=e,this.mockLocalHomePlatform=new o.MockLocalHomePlatform(this)}getLocalHomePlatform(){if(this.allHandlersSet)return this.mockLocalHomePlatform;throw new Error(t.ERROR_HANDLERS_NOT_SET)}getDeviceManager(){return this.mockLocalHomePlatform.getDeviceManager()}listen(){if(void 0===this.identifyHandler)throw new Error(t.ERROR_LISTEN_WITHOUT_IDENTIFY_HANDLER);if(void 0===this.executeHandler)throw new Error(t.ERROR_LISTEN_WITHOUT_EXECUTE_HANDLER);return this.allHandlersSet=!0,Promise.resolve()}onExecute(e){return this.executeHandler=e,this}onIdentify(e){return this.identifyHandler=e,this}onReachableDevices(e){return this.reachableDevicesHandler=e,this}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MockLocalHomePlatform=t.ERROR_EXECUTE_RESPONSE_ERROR_STATUS=t.ERROR_DEVICE_ID_NOT_REGISTERED=t.ERROR_NO_LOCAL_DEVICE_ID_FOUND=t.ERROR_UNDEFINED_EXECUTE_HANDLER=t.ERROR_UNDEFINED_IDENTIFY_HANDLER=t.ERROR_UNDEFINED_VERIFICATIONID=void 0;const o=r(4);t.ERROR_UNDEFINED_VERIFICATIONID="The handler returned an IdentifyResponse with an undefined verificationId",t.ERROR_UNDEFINED_IDENTIFY_HANDLER="Couldn't trigger an IdentifyRequest: The App identifyHandler was undefined.",t.ERROR_UNDEFINED_EXECUTE_HANDLER="Couldn't trigger an ExecuteRequest: The App executeHandler was undefined.",t.ERROR_NO_LOCAL_DEVICE_ID_FOUND="Cannot get localDeviceId of unregistered deviceId",t.ERROR_DEVICE_ID_NOT_REGISTERED="Cannot trigger an ExecuteRequest: The provided deviceId was not registered to the platform",t.ERROR_EXECUTE_RESPONSE_ERROR_STATUS="One or more ExecuteResponseCommands returned with an 'ERROR' status";t.MockLocalHomePlatform=class{constructor(e){this.deviceManager=new o.MockDeviceManager,this.localDeviceIds=new Map,this.app=e}setDeviceManager(e){this.deviceManager=e}getDeviceManager(){return this.deviceManager}isDeviceIdRegistered(e){return this.localDeviceIds.has(e)}getLocalDeviceId(e){if(!this.isDeviceIdRegistered(e))throw new Error(t.ERROR_NO_LOCAL_DEVICE_ID_FOUND);return this.localDeviceIds.get(e)}async triggerIdentify(e,r,o){if(console.log("Received discovery payload:",r),!this.app.identifyHandler)throw new Error(t.ERROR_UNDEFINED_IDENTIFY_HANDLER);const s={requestId:e,inputs:[{intent:smarthome.Intents.IDENTIFY,payload:{device:{id:o,radioTypes:[],udpScanData:{data:r.toString("hex")}},structureData:{},params:{}}}],devices:[]},n=(await this.app.identifyHandler(s)).payload.device;if(void 0===n.verificationId)throw new Error(t.ERROR_UNDEFINED_VERIFICATIONID);return console.log("Registering localDeviceId: "+n.verificationId),this.localDeviceIds.set(n.id,n.verificationId),n.verificationId}async triggerExecute(e,r){if(r.forEach(e=>{e.devices.forEach(e=>{if(!this.localDeviceIds.has(e.id))throw new Error(t.ERROR_DEVICE_ID_NOT_REGISTERED)})}),void 0===this.app.executeHandler)throw new Error(t.ERROR_UNDEFINED_EXECUTE_HANDLER);const o={requestId:e,inputs:[{intent:smarthome.Intents.EXECUTE,payload:{commands:r,structureData:{}}}]},s=(await this.app.executeHandler(o)).payload.commands;return new Promise((e,r)=>{s.forEach(e=>{"ERROR"===e.status&&r(new Error(t.ERROR_EXECUTE_RESPONSE_ERROR_STATUS))}),e(s)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MockDeviceManager=t.ERROR_PENDING_REQUEST_MISMATCH=t.ERROR_UNEXPECTED_COMMAND_REQUEST=void 0,t.ERROR_UNEXPECTED_COMMAND_REQUEST="Unable to process unexpected CommandRequest",t.ERROR_PENDING_REQUEST_MISMATCH="The pending request did not match the expected value";t.MockDeviceManager=class{constructor(){this.expectedCommandToResponse=new Map,this.commandRequestsSent=new Set}getCommandsSent(){return this.commandRequestsSent}clearCommandsSent(){this.commandRequestsSent.clear()}wasCommandSent(e){return this.commandRequestsSent.has(e)}doesNextPendingRequestMatch(e){return new Promise((r,o)=>{this.markPendingAction=s=>{s===e&&r(!0),o(new Error(t.ERROR_PENDING_REQUEST_MISMATCH))}})}addExpectedCommand(e,t){this.expectedCommandToResponse.set(e,t)}markPending(e){return void 0!==this.markPendingAction&&this.markPendingAction(e),Promise.resolve()}getProxyInfo(e){throw new Error("Method not implemented.")}send(e){if(this.commandRequestsSent.add(e),this.expectedCommandToResponse.has(e))return Promise.resolve(this.expectedCommandToResponse.get(e));throw new smarthome.IntentFlow.HandlerError(e.requestId,t.ERROR_UNEXPECTED_COMMAND_REQUEST)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createSimpleExecuteCommands=t.ExecuteStub=void 0,t.ExecuteStub={Response:{Builder:class{constructor(){this.requestId="",this.commands=[]}setRequestId(e){return this.requestId=e,this}setSuccessState(e,t){return this.commands.push({ids:[e],status:"SUCCESS",states:t}),this}setErrorState(e,t){return this.commands.push({ids:[e],status:"ERROR",errorCode:t}),this}build(){return{requestId:this.requestId,payload:{commands:this.commands}}}}}},t.createSimpleExecuteCommands=function(e,t,r,o){return{devices:[{id:e,customData:o}],execution:[{command:t,params:r}]}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(7);global.smarthome=o.smarthomeStub,console.log("stubs injected!")},function(e,t,r){"use strict";var o=this&&this.__createBinding||(Object.create?function(e,t,r,o){void 0===o&&(o=r),Object.defineProperty(e,o,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,o){void 0===o&&(o=r),e[o]=t[r]}),s=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||t.hasOwnProperty(r)||o(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0});const n=r(1);s(r(3),t),s(r(1),t),s(r(2),t),s(r(4),t),s(r(5),t),s(r(0),t),s(r(8),t),s(r(10),t),global.smarthome=n.smarthomeStub},function(e,t,r){"use strict";var o=this&&this.__createBinding||(Object.create?function(e,t,r,o){void 0===o&&(o=r),Object.defineProperty(e,o,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,o){void 0===o&&(o=r),e[o]=t[r]}),s=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.hasOwnProperty.call(e,r)&&o(t,e,r);return s(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.RadioController=t.UDPScanConfig=void 0;const i=n(r(9)),a=r(0);t.UDPScanConfig=class{constructor(e,t,r,o){this.broadcastAddress=e,this.broadcastPort=t,this.listenPort=r,this.discoveryPacket=o}};t.RadioController=class{createTimeoutPromise(e){return new Promise(t=>{setTimeout(t,e)})}async udpScan(e,t=2500){const r=i.createSocket("udp4"),o=new Promise(t=>{r.on("message",(e,o)=>{r.close(),t({buffer:e,rinfo:o})}),r.on("listening",()=>{r.setBroadcast(!0)}),r.bind(e.listenPort);const o=Buffer.from(e.discoveryPacket,"hex");r.send(o,e.broadcastPort,e.broadcastAddress,e=>{if(e)throw new Error("Failed to send UDP discovery packet:\n"+e.message);console.log("Sent UDP discovery packet: ",o)})});return Promise.race([o,this.createTimeoutPromise(t).then(()=>{throw r.close(),new Error(`UDP scan timed out after ${t}ms.`)})])}async sendUdpMessage(e,t,r,o,s=0,n=2500){const c=[],d=i.createSocket("udp4"),u=new Promise(n=>{d.on("message",e=>{c.push(e.toString("hex")),c.length>=s&&(d.close(),n(new a.UdpResponse(c)))}),d.bind(o),d.send(e,r,t,t=>{if(t)throw new Error("Failed to send UDP message: "+t.message);console.log("Sent UDP message: ",e),0===s&&n(new a.UdpResponse)})});return Promise.race([u,this.createTimeoutPromise(n).then(()=>{throw d.close(),new Error(`UDP send timed out after ${n} ms.`)})])}}},function(e,t){e.exports=require("dgram")},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.RadioDeviceManager=void 0;const o=r(0);t.RadioDeviceManager=class{constructor(e,t=3311){this.deviceIdToAddress=new Map,this.radioController=e,this.listenPort=t}addDeviceIdToAddress(e,t){this.deviceIdToAddress.set(e,t)}markPending(e){return Promise.resolve()}getProxyInfo(e){throw new Error("Method not implemented.")}async processUdpRequestData(e){const t=Buffer.from(e.data,"hex"),r=this.deviceIdToAddress.get(e.deviceId),s=await this.radioController.sendUdpMessage(t,r,e.port,this.listenPort,e.expectedResponsePackets);return new o.UdpResponseData(e.requestId,e.deviceId,s)}async send(e){if(!this.deviceIdToAddress.has(e.deviceId))throw new smarthome.IntentFlow.HandlerError(e.requestId);if(console.log(e),"UDP"===e.protocol)return await this.processUdpRequestData(e);throw new Error("Radio protocol not recognized")}}}]);